
# coding: utf-8

# In[3]:

from IPython.display import IFrame
from IPython.core.display import display, HTML
from numpy import pi, arange, ceil, floor, zeros, array, uint8, int8, sin, split, uint16, arange, vstack, set_printoptions, inf, vectorize, hstack, random, sqrt, pi, exp, dtype, float64, add, sin, cos, linspace, sinc, dot, ones
from pylab import binary_repr, digitize, empty
from scipy.io import wavfile
from scipy import signal

import matplotlib.pyplot as plt
import plotly.plotly 
import plotly.graph_objs
import timeit

set_printoptions(threshold=inf)

from plotly import __version__
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
from plotly.graph_objs import Scatter, Figure, Layout

print(__version__) # requires version >= 1.9.0
init_notebook_mode(connected=True)


# In[4]:

IFrame("myJupyterFiles/trab_cps_3.pdf", width=985, height=1200)


# In[4]:

get_ipython().run_cell_magic('time', '', '%matplotlib inline\n    \ndef decodingPCM(R, CodeWord, VTable, SamplesTaken, type="Uniform"):    \n    #==========================================================================\n    # IntTable: all the values back to int\n    #==========================================================================    \n    IntTable=empty(int(len(CodeWord)/R))\n    CodeWord = split(CodeWord, SamplesTaken)\n    decimal = 0\n    i = 0\n    for binaryGroup in CodeWord:\n        for binary in binaryGroup:\n            decimal = decimal * 2 + int(str(binary))\n        IntTable[i] = decimal\n        i+=1\n        decimal = 0\n    return IntTable\n\n    #==========================================================================\n    #  Binary Code Table as Numpy Array\n    # ==========================================================================     \n    OriginalMessage = VTable[IntTable]\n    \n    return OriginalMessage\n\n\ndef encodingPCM(R, IndexTable, type="Uniform"):\n\n    #======================================================================\n    # StringTable: maps in 3 bits all the values in IndexTable, and lists\n    #======================================================================\n    StringTable = list(map(lambda x: binary_repr(x, R), IndexTable))  \n    \n    #==========================================================================\n    # CharTable: maps in 1 bits all the values in StringTable, and then lists\n    #==========================================================================\n    CodingTable = array(zeros(len(StringTable)*R))\n    index = 0\n    for code in StringTable:\n        for bit in code:\n            CodingTable[index] = bit\n            index += 1\n    CodingTable = CodingTable.astype(uint16)   \n    \n    #==========================================================================\n    # Table of Indexes: IndexTable as Figure\n    #==========================================================================  \n    #print("Table of Indexes Used In Sample")\n    #print(vstack(IndexTable))\n    #print("\\n")\n    \n    #==========================================================================\n    # Table of Code: IndexTable as Binary\n    #==========================================================================  \n    #print("Table of Indexes As Binary")\n    #print(vstack(StringTable))\n    #print("\\n")\n\n    #matplotlib.pyplot.figure(figsize=(15,10))\n    #matplotlib.pyplot.title("IndexTable")\n    #matplotlib.pyplot.xlabel("Time (Sampled Signal Index)")\n    #matplotlib.pyplot.ylabel("Vmax (Amplitude)")\n    #matplotlib.pyplot.xticks(arange(len(IndexTable)), StringTable[:])\n    #matplotlib.pyplot.grid()\n    #matplotlib.pyplot.stem(IndexTable, linefmt=\'r:\', markerfmt=\'rs\', basefmt=\'_\')\n    #matplotlib.pyplot.show()\n    #print("\\n")\n    \n    #print(CodingTable)\n    return CodingTable\n\n\ndef quantization(R, Vmax, sampledSignal, SamplesTaken, quantifier="Midrise"):\n    \n    L = 2**R \n    q = 2*Vmax/L \n    \n    if(quantifier=="Midtread"):\n        VTable = arange(-Vmax +q, Vmax +q, q)[::]\n        #DecisionValues = vstack(arange(-Vmax +q/2, Vmax +q/2, q))[:0:-1]\n        #QuantifiedSignal = q * ceil(sampledSignal/q) #midtread\n        QuantifiedSignal = q * floor(sampledSignal/q) #midtread\n\n    else:\n        VTable = arange(-Vmax +q/2, Vmax +q/2, q)[::]\n        #DecisionValues = vstack(arange(-Vmax +q, Vmax +q, q))[-2::-1]\n        #QuantifiedSignal = q * ceil(sampledSignal/q) - q/2 #midrise\n        QuantifiedSignal = q * floor(sampledSignal/q) + q/2 #midrise\n        \n    IndexTable = [x-1 for x in digitize(array(QuantifiedSignal), array(VTable))]  \n    \n    #==========================================================================\n    # Quantified Signal Mq[n]\n    #==========================================================================\n    #print("\\n")\n    #plt.figure(figsize=(15,10))\n    #plt.title("Quantification Mq[n]")\n    #plt.xlabel("Time (Sampled Signal Index)")\n    #plt.ylabel("Vmax (Amplitude)")\n    #plt.yticks(VTable)\n    #plt.xticks(arange(20))\n    #plt.grid()\n    #plt.plot(sampledSignal, \'c\', label=\'M[n]\') \n    #plt.plot(QuantifiedSignal[:SamplesTaken], \'r:\', QuantifiedSignal[:SamplesTaken], \'rs\', label=\'Mq[n]\')\n    #plt.show()\n    #print("\\n")\n    \n    ##=========================================================================\n    # Sampled Signal Table\n    ##=========================================================================\n    #print("Table Sampled Signal")\n    #print(vstack(sampledSignal))\n    #print("\\n")\n\n    #==========================================================================\n    # Quantification Values Table (Midrise)\n    #==========================================================================\n    #print("Table Quantization Type: " + str(quantifier))\n    #print(vstack(VTable))\n    #print("\\n")\n\n    #==========================================================================\n    # Quantified Signal Table\n    #==========================================================================\n    #print("Table Quantization")\n    #print(vstack(QuantifiedSignal))\n    #print("\\n")\n    \n    return IndexTable, VTable, QuantifiedSignal\n\n#=========================================================================\n# Audio Signal Complete ADC\n#=========================================================================\n\n#File = "myJupyterFiles/som_8_16_mono"\n#File = "myJupyterFiles/lightsaber"\nFile = "myJupyterFiles/bach_guitar"\nFs, Data = wavfile.read(File + ".wav")\nSamplesTaken = len(Data)\nDuration = len(Data)/Fs \nSampledSignal = Data[:SamplesTaken]\nAmplitude = max(abs(SampledSignal))\nVmax = Amplitude\nTotalBitErrors = 0\n\nfor RBits in [16]:\n\n    print("\\n")\n    print("New File: " + str(File) + ".wav, RBits=" + str(RBits))\n    print("WavFile Type: " + str(Data.dtype))\n    print("Duration: " + str(Duration))\n    print("Amplitude: " + str(Amplitude))\n    print("SamplesTaken: " + str(SamplesTaken))\n    print("\\n")\n\n    IndexTable, VTable, QuantifiedSignal = quantization(RBits, Vmax, SampledSignal, SamplesTaken)\n    OriginalMessageInBinary = encodingPCM(RBits, IndexTable)\n    M = decodingPCM(RBits, OriginalMessageInBinary, VTable, SamplesTaken)\n\n    ')


# In[5]:

get_ipython().run_cell_magic('time', '', '\ndisplay(HTML(\'<br><p>\\\n1. Construa uma função que implemente o emissor para o código de linha Manchester. Assuma que a entrada é um Numpy array de bits\\\n(com dimensão N), a amplitude do código (A) e o número de pontos (amostras) usado para representar o sinal (P). A saída deverá  \\\nser um Numpy array com o código da sequência (com dimensão N.P).</p>\'\n))\n\ndef unitManchesterTemplate(Value, Voltage, Points):\n    Code = array([  int(Points/2) * ([-1*Voltage]), int(Points/2) * ([Voltage])  ])\n    if Value == 0:\n        return Code.flatten() * -1\n    return Code.flatten()\n\ndef completeManchesterEncoding(OriginalMessageInBinary):\n    Result = map(lambda Binary: unitManchesterTemplate(Binary, Voltage, Points), OriginalMessageInBinary)\n    return hstack(Result)\n\nVoltage = 1\nPoints = 8\n\n#print(OriginalMessageInBinary)\n#EncodedMessage = completeManchesterEncoding(OriginalMessageInBinary)\n#CorrectSize = len(OriginalMessageInBinary) * Points\n\n#EncodedMessage = completeManchesterEncoding([0,1])\n#CorrectSize = len([0,1]) * Points\n\nEncodedMessage = completeManchesterEncoding([0,1,0,1,1,1])\nCorrectSize = len([0,1,0,1,1,1]) * Points\n\ndisplay(HTML("<p>" + str(EncodedMessage) + "</p>"))\ndisplay(HTML("<br>"))')


# In[66]:

get_ipython().run_cell_magic('time', '', 'display(HTML(\'<br><p>\\\n2. Construa uma função que implemente o receptor baseado no filtro adaptado. Este deve receber um código de linha com ruído e \\\ndeve retornar uma sequência binária. Esta função deve ainda ter como parâmetro de entrada o valor de limiar de decisão (λ).</p>\'\n))\n\ndef generatingError(EncodedMessage, Sigma, Lambda):\n    \n    Error = random.normal(Mean, Sigma, len(EncodedMessage))\n    #print(Error)\n\n    plt.figure(figsize=(20, 5), dpi=80, facecolor=\'1\')\n    Count, Bins, Ignored = plt.hist(Error, 30, histtype=\'barstacked\', color=\'xkcd:azure\', normed=True)\n    plt.plot(Bins, (1/(Sigma * sqrt(2 * pi)) * exp( - (Bins - Mean)**2 / (2 * Sigma**2) )), linewidth=2, color=\'xkcd:red orange\')\n    plt.show()\n    \n    MessageWithAWGN = Error + EncodedMessage.astype(float64)\n    \n    plt.figure(figsize=(20, 2.5), dpi=80, facecolor=\'1\')\n    plt.plot(MessageWithAWGN, linewidth=\'0.8\', color=\'xkcd:blue\')\n    plt.xticks(arange(0,len(MessageWithAWGN),Points))\n    plt.xticks(\n        [x for x in arange(0,len(MessageWithAWGN)+Points,Points)], \n        [\'Tb%i\'%x for x in arange(0,(len(MessageWithAWGN)/Points)+1,1)]\n    )\n    for VerticalLine in arange(0,len(MessageWithAWGN)+Points,Points): \n        plt.axvline(x=VerticalLine, color=\'xkcd:red orange\', linestyle=\'dotted\')\n    plt.axhline(y=λ, xmin=0, xmax=1, color=\'xkcd:black\', linestyle=\'solid\', linewidth=\'0.5\')\n    plt.show()\n    return MessageWithAWGN\n\n\nλ = 0\nValues = [0.1e-04, 0.5, 1, 2, 16]\nArrayOfMessagesWithAWGN = empty(len(Values)*len(EncodedMessage))\ni = 0\nfor V in Values:\n    StandardDeviation = σ = DesvioPadrão = sqrt(V)\n    Mean = Média = μ = 0 \n    # Distribuição normal padronizada - equivale à distribuição normal com mu = 0 e sigma = 1. \n    display(HTML(\'<hr>\'))\n    display(HTML("<p>Com σ = " + \'$\\sqrt{\' + str(V) + \'}$\' + ",</p>"))\n    ArrayOfMessagesWithAWGN [ i * len(EncodedMessage) : (i + 1) * len(EncodedMessage) ] = generatingError(EncodedMessage, σ, λ)\n    #display(HTML("<p>" + str(MessageWithAWGN) + "</p>"))\n    display(HTML(\'<br>\'))\n    i += 1')


# In[67]:

get_ipython().run_cell_magic('time', '', '%matplotlib inline\ndef adaptativeFilter(MessageWithAWGN, λ):\n    \n    BaseVector = unitManchesterTemplate(([1]), Voltage, Points).astype(float64)\n    Result = empty(len(MessageWithAWGN))\n    \n    for x in range(int(len(MessageWithAWGN)/Points)):\n        if(dot(MessageWithAWGN[Points * x : Points * (x+1)], BaseVector)) >= λ :\n            Result[Points * x : Points * (x+1)] = unitManchesterTemplate(1, Voltage, Points)\n        else:\n            Result[Points * x : Points * (x+1)] = unitManchesterTemplate(0, Voltage, Points)\n\n            \n    Result = hstack(Result)\n    plt.figure(figsize=(20, 2.5), dpi=80, facecolor=\'1\')\n    plt.plot(Result, linewidth=\'0.8\', color=\'xkcd:blue\')\n    \n    plt.xticks(arange(0,len(Result),Points))\n    plt.xticks(\n        [x for x in arange(0,len(Result)+Points,Points)], \n        [\'Tb%i\'%x for x in arange(0,(len(Result)/Points)+1,1)]\n    )\n    for VerticalLine in arange(0,len(Result)+Points,Points): \n        plt.axvline(x=VerticalLine, color=\'xkcd:red orange\', linestyle=\'dotted\')\n    plt.axhline(y=λ, xmin=0, xmax=1, color=\'xkcd:black\', linestyle=\'solid\', linewidth=\'0.5\')\n    plt.show()\n    return Result\n\n\nλ = 0\ni = 0\nValues = [0.1e-04, 0.5, 1, 2, 16]\nPartitionSize = int((len(ArrayOfMessagesWithAWGN)/len(Values)))\nfor V in Values:\n    display(HTML(\'<hr>\'))\n    display(HTML("<p>Com valor de limiar de decisão (λ) = " + str(λ)  + " e com σ = " + \'$\\sqrt{\' + str(V) + \'}$\' + ",</p>"))\n    RecoveredMessage = adaptativeFilter(ArrayOfMessagesWithAWGN[i * PartitionSize : (i+1) * PartitionSize], λ)\n    i += 1\n    #display(HTML("<p>" + str(RecoveredMessage) + "</p>"))\n    display(HTML(\'<br>\'))')


# In[94]:

get_ipython().run_cell_magic('time', '', '\ndisplay(HTML(\'<br><p>\\\n3. Adapte as funções anteriores para funcionarem com o código de linha Manchester diferencial.\'\n))\n\ndef ManchesterTemplate(Value, Voltage, Points):\n    Code = array([  int(Points/2) * ([-1*Voltage]), int(Points/2) * ([Voltage])  ])\n    if Value == 0:\n        return Code.flatten() * -1\n    return Code.flatten()\n\n\ndef completeManchesterEncoding(OriginalMessageInBinary, Voltage, Points):\n    \n    Result = empty(len(OriginalMessageInBinary)*Points)\n    Previous = 1\n    Index = 0\n    for x in OriginalMessageInBinary:\n        Result[Index * Points : (Index + 1) * Points] = ManchesterTemplate((x ^ Previous), Voltage, Points)\n        Previous = x ^ Previous\n        Index +=1\n    return hstack(Result)\n\nVoltage = 5\nPoints = 10\nEncodedMessage = completeManchesterEncoding([1,0,1,0,0,0,0,1,1,1,1,0,0,1,1], Voltage, Points)\nCorrectSize = len(OriginalMessageInBinary) * Points\nplt.figure(figsize=(20, 2.5), dpi=80, facecolor=\'1\')\nplt.plot(EncodedMessage, linewidth=\'0.9\')\n\ndisplay(HTML("<p>" + str(CorrectSize) + "</p>"))\ndisplay(HTML("<p>" + str(len([EncodedMessage])) + "</p>"))\ndisplay(HTML(\'<br>\'))')


# In[ ]:



